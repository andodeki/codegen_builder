{{if .IsAttachment}}
        -- attachement presentation code  --
    {{else}}{{if .IsMenu}}
        -- menu --
    {{else}}
        -- default code --
{{end}}{{end}}
  {{if eq $index 0}}
        WHERE {{.Name}} IS NOT NULL
    {{- else}}{{if or (contains .Name "created") (contains .Name "role")}}
        AND {{.Name}} IS NOT NULL
    {{else}}
        {{.}}
{{end}}{{end}}
{{if eq $index 0}}WHERE {{.Name}} IS NOT NULL
  {{- else}}{{if or (contains .Name "created") (contains .Name "role")}}AND {{.Name}} IS NOT NULL{{end -}}
{{end}}
{{- range $index, $element := .ProductTargets.Structs}}
{{$target := index $element 0}}--{{$target.Name}} 
CREATE MATERIALIZED VIEW IF NOT EXISTS {{$index.Name}}_by_{{$target.Name}} AS 
  SELECT * FROM {{$index.Name}}
{{- range $index, $item := $element -}} 
  {{if eq $index 0}}
  WHERE {{.Name}} IS NOT NULL
  {{- else}}{{if or (contains .Name "id") (contains .Name "created") (contains .Name "role")}}
  AND {{.Name }} IS NOT NULL
  {{- else -}}{{ end -}}
{{end}}{{end}}
  PRIMARY KEY({{range $index, $item := $element -}} 
{{- $lenProperties := len $element -}}
  {{if or (contains .Name "id") (contains .Name "created") (contains .Name "role") (contains .Name "expires")}}
    {{- .Name}}{{if (isLast $index $lenProperties)}}{{- else}},{{end}}
  {{- else -}}{{ end -}}
{{end}});
{{end}}


  PRIMARY KEY{{range $index, $item := $element -}}
  {{if eq $index 0}}({{.Name}},{{if ne $index 0}}{{.Name}}{{end}});{{end}}{{else}}


/*
-- AUTO GENERATED By codegen_builder, DO NOT EDIT
{{range $index, $item := .ProductTargets.TableNames -}}
CREATE TABLE IF NOT EXISTS {{$item.ProductSource}}.{{$item.Name}}(
{{$lenProperties := len .Properties -}}
{{range $index, $item := .Properties -}} 
    <brt>{{  .Name}} {{.TypeNames}}{{if (isLast $index $lenProperties)}},{{else}},{{end}}
{{end -}}
<brt>PRIMARY KEY{{range $index, $item := .Properties -}}
    {{if eq $index 0}}({{.Name}}, {{if eq $index 0}}{{.Name}}{{end}}){{end}}{{else}}break
{{end}}
);
{{end -}}



{{range $index, $item := .ProductTargets.TableNames -}} 
CREATE MATERIALIZED VIEW IF NOT EXISTS {{$item.Name}}_by_{{trimSuffix "s" $item.Name}}_id AS 
<brt>SELECT * FROM {{$item.Name}}
<brt>WHERE u_{{trimSuffix "s" $item.Name}}_id IS NOT NULL
<brt>AND u_created_at IS NOT NULL
<brt>AND u_email IS NOT NULL
<brt>AND u_phone IS NOT NULL
<brt>PRIMARY KEY (u_{{trimSuffix "s" $item.Name}}_id, u_created_at, u_email);
{{end -}}

{{range $index, $item := .ProductTargets.IndexNames -}} 
{{if $item }}
CREATE INDEX {{$item.Name}} ON {{$item.Name}} (
{{range $index, $item := .DBIndexes -}} 
    <brt>{{  .Name}},
{{end -}}
);
{{end}}
{{end -}}




{{- range $index, $element := .ProductTargets.Types -}}
{{if $element }}
CREATE TYPE {{ $index }} (
{{- $lenTypes := len $element -}}
{{- range $index, $item := $element}}
    {{$item.Name}}{{if (isLast $index $lenTypes)}}{{- else}},{{end -}}
{{end}}
);
{{end -}}
{{- end -}}



{{ range $index, $item := .ProductTargets.TypeNames}}
{{if $item }}
CREATE TYPE {{ $item }} (

);
{{end}}
{{end}}

*/

package main

import (
	"encoding/json"
	"fmt"
)

type Enum struct {
	Name       string
	CustomType string
}

func main() {
	jsonStr := "[{\"owner_type\":[\"rental\",\"buying\",\"leasing\",\"\"]}]"

	var results []map[string][]string

	json.Unmarshal([]byte((jsonStr)), &results)

	var enums []Enum

	for _, m := range results {
		for name, values := range m {
			for _, v := range values {
				enum := Enum{Name: name, CustomType: v}
				enums = append(enums, enum)
			}
		}
	}

	fmt.Printf("results: %v\n", enums)
}

for tblName, tableFields := range tableMap {
				// fmt.Printf("tableMap: %v<<<{%q}>>>\n", k, (value))
				for _, v := range tableFields {
					// fmt.Printf("tableFields: %v\n", (tableFields))
					for _, vj := range v {
						if len(vj) > 6 {
							lines := delete_empty(strings.Split(strings.Replace(vj, "(", "", -1), " "))
							tableFinal2 = append(strings.Split(strings.Join(lines[:2], " "), " "))
							tableLineFinal3 = append(tableLineFinal3, tableFinal2)
							tableFields = tableLineFinal3
						}
						// if dataSql.ProductFileType == ".cql" {
						// 	// dataSql
						// 	tblname := TableName{Name: key}
						// 	dataSql.ProductTargets.TableNames = append(dataSql.ProductTargets.TableNames, tblname) //append(dataSql.ProductTargets.TableNames, tableName)
						// 	dataSql.FolderPathName = "./tmp/datasources/migrations/cqlmigrations/"
						// 	if strings.Contains(f.Name(), ".up.sql") {
						// 		dataSql.ProductTargets.OutputFilename = before(f.Name()[7:], "_table.up.sql")
						// 	}
						// 	if strings.Contains(f.Name(), ".down.sql") {
						// 		dataSql.ProductTargets.OutputFilename = before(f.Name()[7:], ".down.sql")
						// 	}

						// 	dataModel.ProductTargets.TableNames = append(dataModel.ProductTargets.TableNames, tblname)
						// 	dataModel.ProductTargets.StructNames = append(dataModel.ProductTargets.StructNames, tblname)
						// 	if strings.Contains(f.Name(), ".up.sql") {
						// 		dataModel.ProductTargets.OutputFilename = before(f.Name()[7:], "_table.up.sql")
						// 	}
						// 	if strings.Contains(f.Name(), ".down.sql") {
						// 		dataModel.ProductTargets.OutputFilename = before(f.Name()[7:], ".down.sql")
						// 	}
						// 	dataModel.FolderPathName = "./tmp/models/"
						// 	// dataModel.ProductTargets.TableNames.
						// 	propt.Name = v[0]
						// 	fmt.Printf("v[0]: %v\n", v[0])
						// 	propt.TypeName = toOutPutDataType(v[1], dataSql)
						// 	propt.Tag = ""
						// 	dataSql.AddProperty(propt)
						// }
						// if dataModel.ProductFileType == ".go" {
						// 	propt.Name = strings.Replace(cases.Title(language.Und, cases.NoLower).String(strings.Replace(v[0][2:], "_", " ", -1)), " ", "", -1)
						// 	propt.TypeName = toOutPutDataType(v[1], dataModel)

						// 	if ij == 0 {
						// 		propt.Tag = fmt.Sprintf(`json:"%s,omitempty" db:"%s"`, propt.Name, v[0])
						// 	} else {
						// 		propt.Tag = fmt.Sprintf(`json:"%s" db:"%s"`, strings.ToLower(propt.Name), v[0])
						// 	}
						// 	dataModel.AddProperty(propt)
						// }
					}
				}
				tableMap[tblName] = tableFields

				// jsonStr, _ := json.MarshalIndent(tableMap, "", "  ")
				// fmt.Printf("jsonStr: %q\n", "["+string(jsonStr)+"]")

				for _, v := range tableFields {
					if dataSql.ProductFileType == ".cql" {
						pt := new(ProductTarget)
						pt.Structs = make(map[TableName][]Property)
						// dataSql
						tblname := TableName{Name: tableName}
						// psrc := TableName{ProductSource: "propertylist"}
						// dataSql.ProductTargets.TableNames = append(dataSql.ProductTargets.TableNames, tblname) //append(dataSql.ProductTargets.TableNames, tableName)
						// dataSql.ProductTargets.TableNames = append(dataSql.ProductTargets.TableNames, psrc)
						dataSql.FolderPathName = "./tmp/datasources/migrations/cqlmigrations/"
						if strings.Contains(f.Name(), ".up.sql") {
							dataSql.ProductTargets.OutputFilename = before(f.Name()[7:], "_table.up.sql")
						}
						if strings.Contains(f.Name(), ".down.sql") {
							dataSql.ProductTargets.OutputFilename = before(f.Name()[7:], ".down.sql")
						}

						dataModel.ProductTargets.TableNames = append(dataModel.ProductTargets.TableNames, tblname)
						dataModel.ProductTargets.StructNames = append(dataModel.ProductTargets.StructNames, tblname)
						if strings.Contains(f.Name(), ".up.sql") {
							dataModel.ProductTargets.OutputFilename = before(f.Name()[7:], "_table.up.sql")
						}
						if strings.Contains(f.Name(), ".down.sql") {
							dataModel.ProductTargets.OutputFilename = before(f.Name()[7:], ".down.sql")
						}
						dataModel.FolderPathName = "./tmp/models/"
						propt.Name = v[0]
						// propt.TypeName = toOutPutDataType(v[1], dataSql)
						propt.Tag = ""
						pt.Name = tblName
						// tblname2 := TableName{tableName, "propertylist"}
						// pt.Structs[tblname2] = dataSql.AddProperty(propt)
					}
				}
				dataSql.ClearProperty()
			}


{{- range $index, $element := .ProductTargets.Structs -}}
//{{$index.Name}}
type User{{title $index.Name}} struct { 
{{range $index, $item := $element -}}
  {{.Name}} {{.TypeName}} `{{.Tag}}`
{{end}}
}
{{end -}}


pgdbs := make([]map[string][]map[string]interface{}, 0)
	pg := map[string]interface{}{
		"Enabled": "True",
		"Name":    "propertylistingapi",
	}
	var pglist []map[string]interface{}
	pglist = append(pglist, pg)
	pgdb1 := map[string][]map[string]interface{}{
		"0-postgres": pglist,
	}
	pgdb0 := map[string][]map[string]interface{}{
		"0-postgres": []map[string]interface{}{
			{"Enabled": "True"},
			{"Name": "propertylistingapi"},
		},
	}
	pgdbs = append(pgdbs, pgdb1, pgdb0)
	value4 := map[string]interface{}{"PostgresClients": []map[string][]map[string]interface{}{
		{
			"0-postgres": []map[string]interface{}{
				{"Enabled": "True"},
				{"Name": "propertylistingapi"},
				{"DatabaseHost": "10.38.195.235"},
				{"DatabasePort": 5432},
			},
		},
	},
	}
	value5 := map[string]interface{}{"ScyllaDBClients": []map[string][]map[string]interface{}{
		{
			"0-scylla": []map[string]interface{}{
				{"Enabled": "True"},
				{"Name": "scylla-node0"},
				{"DatabaseHost": "10.38.195.235"},
				{"DatabasePort": 5432},
			},
		},
		{
			"1-scylla": []map[string]interface{}{
				{"Enabled": "True"},
				{"Name": "scylla-node1"},
				{"DatabaseHost": "10.38.195.235"},
				{"DatabasePort": 5432},
			},
		},
	},
	}