package gen_startup

import (
	"fmt"

	"github.com/andodeki/gen_project/aOK_GenerateCode/dir"
	// "github.com/andodeki/gen_project/aOK_GenerateCode/gen_startup/gen_http"
	"github.com/andodeki/gen_project/aOK_GenerateCode/project"
)

var (
	header = ` 
//AUTO GENERATED By gen_main.go, DO NOT EDIT
package main

import (
	%s
)

// is set through linker by build.sh
var buildVersion string
var buildTime string

func Application(cfg *config.Config) {
	cmdOptions, cmdName := getCmdOptions()
	logger := util.NewLogger(*cfg)

	if cfg.LogWorkerStart {
		logger.Infof("main: start test_1 version=%s", buildVersion)
	}

	// start cpu profiling if enabled
	if runCpuProfile(string(cmdOptions.CpuProfile)) {
		defer pprof.StopCPUProfile()
	}

	exitCode := func() (exitCode int) {
		// whenever an error is pushed to this chan, main is terminated
		initiateShutdown := make(chan error, 4)
		

		var client *datasources.DatabaseClient
		var scyllaClient *datasources.ScyllaDBClient
		var redisClient *datasources.RedisClient

		emailInAppQueue := queue.NewEmailQueue(logger, cfg)

		promExporter, errPromE := datasources.NewOTExporter(context.Background(), logger, cfg, initiateShutdown)
			if errPromE != nil {
				logger.Infof("main: datasources.NewOTExporter: %s", errPromE)
			}

		httpServerInstance := runHttpServer(logger, cfg, emailInAppQueue, client, redisClient, scyllaClient, promExporter)
		defer httpServerInstance.Shutdown()

		if cfg.LogWorkerStart {
			logger.Print("main: start completed; run until SIGTERM or SIGINT is received")
		}
	}()
	if cfg.LogWorkerStart {
		logger.Infof("main: stutdown completed; exit %d", exitCode)
	}
	os.Exit(exitCode)
}
`
)

var StartAppImports = []string{
	"src/util",
	"src/config",
	"src/datasources",
	"src/queue",
}

func Generate_StartupContents() {
	sb := dir.FormStringDir(project.ProjectName, StartAppImports)
	stringFormat := "%s"

	startup_ := fmt.Sprintf(header, sb.String(), stringFormat)
	dir.Create_Files(startup_, "startup.go")
	Generate_HTTPServerImportsContents()

}
